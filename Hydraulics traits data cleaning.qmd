---
---
title: "Hydraulics Traits data cleaning"
format: html
editor: visual
author : Mathéo TOURIERE
date : Today
---

## Data Import

```{r include: FALSE}
rm(list = ls())
library(tidyverse)
library(ggplot2)
library(readxl)
#library("here")
library(tidyr)
library(dplyr)
library(pvcurveanalysis)
library(googlesheets4)
library(imager)
library(jsonlite)


#local import (without internet)
#field_data <-  read.csv(file = here("Fieldwork_spreadsheet.csv"),dec = ",")

```

```{r importing directly from google sheet if internet}

# Authentification 
gs4_auth()

#URL google sheet
sheet_PV_url <- "https://docs.google.com/spreadsheets/d/1NXFZCGgbadWr4-rOg-YzXA_Oogk4Kti_uWWhwoU-knc/edit?gid=1002499086#gid=1002499086" #Pv data
sheet_SP_url <- "https://docs.google.com/spreadsheets/d/1S2ruGvcPbTalryl_l5ROC57WxArjDPjvbv6DEaFjq6g/edit?gid=1277829208#gid=1277829208"  #Stomatal data


# Read
PV_data <- read_sheet(sheet_PV_url)
SP_data <- read_sheet(sheet_SP_url, sheet = "Stomatal density")
cond_data <- read_sheet(sheet_SP_url, sheet = "Conductance")
cond_data$collection_time <- cond_data$collection_time |> 
  as.POSIXct(format="%Y-%m-%d %H:%M:%S") |> 
  format(format="%H:%M:%S")
```

## Hydraulics analysis

Creation of the data frame needed for the analysis

```{r Creation of the data frame needed for the analysis}

select_PV_data <- select(PV_data,"envelope_ID",starts_with("fresh"),starts_with("water"),"dry.weight.g") 

index_w0 <- which(names(select_PV_data) == "fresh.weight.0.g")
index_wf <- which(names(select_PV_data) == "fresh.weight.13.g")

index_wat0 <- which(names(select_PV_data) == "water.potential.0.bar")
index_watf <- which(names(select_PV_data) == "water.potential.13.bar")

 pv_data_weight <- select_PV_data |> 
    select(envelope_ID, fresh.weight.0.g:fresh.weight.13.g,fresh.weight.harvest.g,fresh.weight.satured.g,dry.weight.g) |> 
   pivot_longer(cols = fresh.weight.0.g:fresh.weight.13.g,values_to = "fresh.weight.g")|>
  select(-name)

pv_data_water<- select_PV_data |> 
    select(envelope_ID, water.potential.0.bar:water.potential.13.bar) |> 
    pivot_longer(cols = water.potential.0.bar:water.potential.13.bar,
                 values_to = "water.potential.bar")|> 
    select(-name) 

pv_data <- na.omit(data.frame(c(pv_data_weight,
                                select(pv_data_water,water.potential.bar) )))
 
 pv_data <- pv_data |> 
   group_by(envelope_ID) |> 
  mutate(measurment.id = row_number()) |> 
   ungroup()

pv_data <- pv_data |> 
   RelativeWaterDeficit( fresh.mass = "fresh.weight.g", dry.mass = "dry.weight.g",
                           fresh.mass.saturated = "fresh.weight.satured.g") #new column with RWD |> 
        

 
 pv_data$envelope_ID <- as.integer(pv_data$envelope_ID) 


```

Creation of plots

```{r Creation of plots}
# Function for ploting PV curves
plot_water_potential <- function(data) {
  # Vérifier que les colonnes nécessaires sont présentes dans le dataframe
  if (!all(c("water.potential.bar", "RWD", "envelope_ID") %in% colnames(data))) {
    stop("columns 'water.potential.bar', 'RWD', et 'envelope_ID' need to be in the dataframe")
  }
  
  # Calculation -1 / water.potential
  data$neg_inverse_water_potential <- -1 / data$water.potential.bar
  
  # ID of the samples
  unique_samples <- unique(data$envelope_ID)
  
  # list to store plots
  plot_list <- list()
  
  # plot PVc for each sample
  for (sample in unique_samples) {
    sample_data <- data[data$envelope_ID == sample, ]

    
    p <- ggplot(sample_data, aes(x = RWD, y = neg_inverse_water_potential, label = measurment.id), vjust = -1, hjust = 0.5) +
      geom_point() +
      geom_line() +
      geom_label() +
      #geom_label(aes(label = sample_data$measurment.id), vjust = -1, hjust = 0.5) +
      labs(
        title = paste("Sample", sample, "Pressure-Volume curve"),
        x = "Relative Water Deficit (RWD)",
        y = "-1 / Water Potential (MPa^-1)"
      ) +
#      scale_color_gradient(low = "blue", high = "red", name = "point.id") +
      theme_minimal()
    
    # add plot in the list
    plot_list[[as.character(sample)]] <- p
  }
  
  return(plot_list)
}

```

using the plot function :

```{r}
# Using the plotting function 
 plot_list <- plot_water_potential(pv_data)

# Afficher les graphiques
 for (p in plot_list) {
   print(p)
 }
```

Calculation of the turgor loss point

```{r Calculation of the turgor loss point}
#pv_data <- pv_data[pv_data$plateau != "yes",] 

#PV_data <- PV_data[-(1:1),]
#Turgor loss point f(RWD) = -1/psi

# result_pv1 <- TurgorLossPoint(pv_data, sample = "envelope_ID", graph = TRUE) 
# water.potential.tlp <- ExtractParam(result_pv1)


result_pv <- pv_data |> 
  select(envelope_ID,water.potential.bar,RWD) |> 
  OsmoticPot( sample = "envelope_ID", graph = TRUE, water.potential = "water.potential.bar", RWD = "RWD") 
osmotic.pot <- ExtractParam(result_pv)

result_elasticity <- ModElasticity(pv_data, sample = "envelope_ID",water.potential = "water.potential.bar", graph = TRUE) 
mod.elas <- ExtractParam(result_elasticity)





```

Deleting (bad) points

```{r Deleting (bad) points}
# Ajout d'une colonne 'remove' initialisée avec NA
pv_data$remove <- NA

# Boucle à travers chaque échantillon
for (j in 1:length(unique(pv_data$envelope_ID))) {
 pv_data_f <- pv_data[pv_data$envelope_ID == j, ] #keep all lines
  
# for (i in 1:nrow(pv_data_f)) {
#   # Affiche les informations du sample actuel
#   cat("Envelope ID:", pv_data$envelope_ID[j], "measurment ID:", pv_data_f$measurment.id[i], "/n")
  
  # Demande à l'utilisateur s'il souhaite enlever des points
  remove_points <- readline(prompt = paste("Souhaitez-vous enlever des points pour l'envelope_id", pv_data_f$envelope_ID[1], "(yes/no) ? "))
  
  if (tolower(remove_points) == "yes") {
    repeat {
      # Demande l'identifiant du point à enlever
      measurment.id <- as.integer(readline(prompt = "Quel measurment.id souhaitez-vous enlever ? "))
      
      # Vérifie si le measurment.id existe dans le DataFrame
      if (measurment.id %in% pv_data_f$measurment.id) {
        pv_data$remove[pv_data$envelope_ID == j & pv_data$measurment.id == measurment.id] <- "yes"
      } else {
        cat("measurment ID non trouvé dans les données./n")
      }
      
      # Demande à l'utilisateur s'il souhaite enlever un autre point
      another <- readline(prompt = "Souhaitez-vous enlever un autre point pour le même envelope_id (yes/no) ? ")
      if (tolower(another) != "yes") {
        break
      }
    }
  }

}


# Complète les cases vides avec 'no'
pv_data$remove[is.na(pv_data$remove)] <- "no"
```

```{r}

pv_data <- pv_data[pv_data$remove != "yes",] 

#PV_data <- PV_data[-(1:1),]
#Turgor loss point f(RWD) = -1/psi

# result_pv1 <- TurgorLossPoint(pv_data, sample = "envelope_ID", graph = TRUE) 
# water.potential.tlp <- ExtractParam(result_pv1)

result_pv <- OsmoticPot(pv_data, sample = "envelope_ID", water.potential = "water.potential.bar", graph = TRUE) 
osmotic.pot <- ExtractParam(result_pv)

result_elasticity <- ModElasticity(pv_data, sample = "envelope_ID",water.potential = "water.potential.bar", graph = TRUE) 
mod.elas <- ExtractParam(result_elasticity)
```

## Stomatal analysis

```{r calculation Stomatal density}

SP_data <- SP_data|> 
  mutate(habitat = ifelse(is.na(habitat), DroughtTrt, habitat)) |> 
   mutate(stomatal_density_S1 = rowMeans(select(SP_data,starts_with("stomatal_peels_S1")), na.rm = TRUE)/SP_data$Area_mm2) |> 
     mutate(stomatal_density_S2 = rowMeans(select(SP_data,starts_with("stomatal_peels_S2")), na.rm = TRUE)/SP_data$Area_mm2) |>
     mutate(stomatal_density_S3 = rowMeans(select(SP_data,starts_with("stomatal_peels_S3")), na.rm = TRUE)/SP_data$Area_mm2) |>
    mutate(across(starts_with("stomatal_density"), ~ ifelse(is.nan(.), NA, .)))


```

Calcul de la surface moyenne des stomates

```{r calculation of the stomatal area}

# Chargement des annotations
#annotations <- fromJSON("D:/Utilisateurs/Touriere/Téléchargements/DURIN_SP_area_test.v2i.coco-segmentation/train/_annotations.coco.json")

annotations <- fromJSON("C:/Users/Touriere/Desktop/GEN/4A/SIRD/Data/Stomatal_peels/DURIN_SP_area.v5i.coco-segmentation/train/_annotations.coco.json")


annotations_df <- as.data.frame(annotations$annotations)
images_df <- as.data.frame(annotations$images)
images_df$file_name <- gsub("-", ".", images_df$file_name)

images_df_DN <-  subset(images_df, grepl("DN", file_name))|> 
    mutate(photo_id = substr(file_name, 1, 18)) |> 
    mutate(plant_id = substr(file_name, 1, 12))

images_df <- subset(images_df, !grepl("DN", file_name))|>
    mutate(photo_id = substr(file_name, 1, 14)) |> 
    mutate(plant_id = substr(file_name, 1, 8)) 
#  rbind(images_df_DN)

#calculation for open and forested
# Charger les catégories pour obtenir le nom des classes
categories_df <- as.data.frame(annotations$categories)

# Fusionner les annotations avec les catégories pour obtenir le nom des classes
annotations_df_OF <- merge(annotations_df, images_df, by.x = "image_id", by.y = "id")
annotations_df_OF <- merge(annotations_df_OF, categories_df, by.x = "category_id", by.y = "id")  |> 
  select(category_id, image_id, id, area, plant_id, photo_id, "classe_name" = name) |> 
  mutate(species = substr(photo_id, 6, 7))

# Filtrer pour la classe cible
target_annotations <- annotations_df_OF |> 
  filter(classe_name == "DURIN-stomatal-peels_VM_pol")

optique_info <- annotations_df_OF |> 
  filter(classe_name == "Optique") |> 
  mutate(area_mm2 = 0.07068583471) |> 
  mutate(conversion_factor = area_mm2 / area)

target_annotations<- target_annotations |> 
  merge(select(optique_info, image_id, conversion_factor)) |> 
  mutate(area_mm2 = area*conversion_factor) 

stomata_surface_OF <- target_annotations |> 
  group_by(image_id) |> 
  summarise(mean_area_mm2_sample = mean(area_mm2)) |>
  ungroup() |> 
  left_join(target_annotations, by = "image_id") |> 
  distinct(image_id, .keep_all = TRUE) |> 
  select(plant_id, species, image_id, photo_id, mean_area_mm2_sample)  #mean of all the stomatas present on the picture

mean_stomata_surface_OF <- stomata_surface_OF|>
  group_by(plant_id) |> 
  summarise(mean_area_mm2 = mean(mean_area_mm2_sample)) |>
  mutate(mean_area_um2 = mean_area_mm2*10^6) |> 
  ungroup() |> 
  left_join(target_annotations, by = "plant_id") |> 
  distinct(plant_id, .keep_all = TRUE) |> 
  select(species, plant_id, mean_area_mm2, mean_area_um2)  #mean of the size for all the pictures for one plant 

#calculation for DN
# Fusionner les annotations avec les catégories pour obtenir le nom des classes
annotations_df_DN <- merge(annotations_df, images_df_DN, by.x = "image_id", by.y = "id")
annotations_df_DN <- merge(annotations_df_DN, categories_df, by.x = "category_id", by.y = "id") |> 
  select(category_id, image_id, id, area, height, width, plant_id, photo_id, "classe_name" = name) |> 
  mutate(species = substr(photo_id, 10, 11))

# Filtrer pour la classe cible
target_annotations_DN <- annotations_df_DN |> 
  filter(classe_name == "DURIN-stomatal-peels_VM_pol")

optique_info_DN <- annotations_df_DN |> 
  filter(classe_name == "Optique") |> 
  mutate(area_mm2 = 0.07068583471) |> 
  mutate(conversion_factor = area_mm2 / area)

target_annotations_DN<- target_annotations_DN |> 
  merge(select(optique_info_DN, image_id, conversion_factor)) |> 
  mutate(area_mm2 = area*conversion_factor) 

stomata_surface_DN <- target_annotations_DN |> 
   group_by(image_id) |> 
  summarise(mean_area_mm2_sample = mean(area_mm2)) |>
  ungroup() |> 
  left_join(target_annotations_DN, by = "image_id") |> 
  distinct(image_id, .keep_all = TRUE) |> 
  select(plant_id, species, image_id, photo_id, mean_area_mm2_sample)

mean_stomata_surface_DN <- stomata_surface_DN |> 
  group_by(plant_id) |> 
  summarise(mean_area_mm2 = mean(mean_area_mm2_sample)) |> 
  mutate(mean_area_um2 = mean_area_mm2*10^6) |> 
  ungroup() |> 
  left_join(target_annotations_DN, by = "plant_id") |> 
  distinct(plant_id, .keep_all = TRUE) |> 
  select(species, plant_id, mean_area_mm2, mean_area_um2)

stomata_surface <- rbind(stomata_surface_OF,stomata_surface_DN)


mean_stomata_surface <- rbind(mean_stomata_surface_OF,mean_stomata_surface_DN)



```

environment cleanning

```{r}
# Liste de tous les objets dans l'environnement
all_objects <- ls()

# Objets à conserver
keep_objects <- c("SP_data", "PV_data", "stomata_surface", "mean_stomata_surface", "cond_data")

# Objets à supprimer (tous sauf ceux à conserver)
remove_objects <- setdiff(all_objects, keep_objects)

# Supprimer les objets à supprimer
rm(list = remove_objects)

```

filtering

```{r}
SP_data <- SP_data|>
  mutate(stomatal_density_mean = rowMeans(select(SP_data,starts_with("stomatal_density")), na.rm = TRUE))

SP_data <- mean_stomata_surface |> 
  select(-species) |> 
  left_join(SP_data, by = "plant_id") |> 
  relocate(mean_area_mm2, mean_area_um2, .after = stomatal_density_mean)

SP_data_OF <-subset(SP_data, is.na(DroughtTrt))
SP_data_DN <-subset(SP_data, !is.na(ageClass))
SP_data_LY_O<- SP_data |> 
  filter(siteID == "Lygra") |> 
  filter( habitat != "Forested")

SP_data_OF <- SP_data_OF |> 
  select(-ageClass, -DroughtNet_Plot, -DroughtTrt)

SP_data_DN <- SP_data_DN |> 
  select(-habitat, -Nearest_plotID)
```

Conductance analysis

```{r}

cond_data <- cond_data |> 
    mutate(stomatal_conductance_mean = rowMeans(select(cond_data,starts_with("stomatal_conductance")), na.rm = TRUE))

cond_data_r <- cond_data |>
  rename(species_full = species) |> 
  mutate(species = case_when(
    species_full == "Vaccinium vitis-idaea" ~ "VV",
    species_full == "Vaccinium myrtillus" ~ "VM",
    TRUE ~ NA_character_  # pour toutes les autres espèces, mettre NA
  )) |> 
  select(species, DroughtTrt, DroughtNet_plot, Nearest_plotID, starts_with("stomatal_conductance")) |> 
  mutate(cond_code = paste0(species, "-", Nearest_plotID))

cond_data_OF <- cond_data_r |> 
  filter(is.na(DroughtNet_plot))

cond_data_DN <- cond_data_r |> 
  filter(!is.na(DroughtNet_plot))


SP_data <- SP_data |> 
  rename(species_full = species) |> 
  mutate(species = case_when(
    species_full == "Vaccinium vitis-idaea" ~ "VV",
    species_full == "Vaccinium myrtillus" ~ "VM",
    TRUE ~ NA_character_  # pour toutes les autres espèces, mettre NA
  )) |> 
    mutate(cond_code = paste0(species, "-", Nearest_plotID))
  
  SP_data <- SP_data |> 
  left_join(select(cond_data_r,cond_code, stomatal_conductance_mean), by = "cond_code")

```

plotting

```{r}


base <- ggplot(SP_data_OF, aes(x = species, y = stomatal_density_mean))

p_box <- base + geom_boxplot(aes(fill = species))
p_box_2 <- base + geom_boxplot(aes(fill = siteID))
p_vio <- base + geom_violin(aes(fill = species))
p_vio_2 <- base + geom_violin(aes(fill = siteID))
p_point <- base + geom_point(aes(colour = species))
p_jit <- base + geom_jitter(aes(colour = species))
library(ggforce)
p_sina <- base + geom_sina(aes(colour = species))

p_box
p_box_2
p_vio 
p_vio_2
p_point
p_jit
library(ggforce)
p_sina


#mutate(stomatal_conductivity = rowMeans(select(SP_data,starts_with("stomatal_density")), na.rm = TRUE))

```

2

```{r}
p_vio <- ggplot(SP_data_OF, aes(x = species, y = stomatal_density_mean)) +
  geom_violin(aes(fill =siteID,fill = habitat))
p_vio

f_grid <-  ggplot(SP_data_OF,aes(x = species, y = stomatal_density_mean))+
  geom_boxplot(aes(fill = habitat)) +
  facet_grid(. ~ siteID)

f_grid
#f_wrap <- facet_wrap()

p_vio2 <- SP_data_LY_O|> 
  ggplot(aes(x = species, y = stomatal_density_mean)) +
  geom_boxplot(aes(fill = habitat))
p_vio2
#p_error <- SP_data_LY_O|> 
 # ggplot(aes(x = species, y = stomatal_density_mean)) +
  #geom_errorbar()
#p_error
```
